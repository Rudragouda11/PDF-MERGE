<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PDF Merge & Split Pro</title>
  <style>
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f0f2f5; margin: 0; padding: 0; display: flex; flex-direction: column; align-items: center; }
    header { background: linear-gradient(90deg,#4285f4,#34a853); color: white; padding: 20px; width: 100%; text-align: center; font-size: 28px; font-weight: bold; box-shadow: 0 2px 6px rgba(0,0,0,0.2);}
    main { max-width: 900px; width: 95%; margin-top: 30px;}
    .tabs { display: flex; justify-content: center; margin-bottom: 20px;}
    .tab-btn { flex: 1; padding: 12px 0; cursor: pointer; border: none; background: #ddd; font-weight: bold; transition: 0.3s; font-size: 16px;}
    .tab-btn.active { background: #4285f4; color: white;}
    .tab-content { display: none; flex-direction: column; align-items: center; background: white; padding: 20px; border-radius: 15px; box-shadow: 0 6px 15px rgba(0,0,0,0.15); margin-bottom: 40px; width: 100%;}
    .tab-content.active { display: flex;}
    input[type="file"] { display:none; }
    .drop-zone { border: 2px dashed #bbb; padding: 30px; border-radius: 15px; text-align: center; margin-bottom: 15px; color: #555; transition: 0.3s; width: 100%;}
    .drop-zone.dragover { border-color: #4285f4; background: #e3f0ff; color: #000;}
    button { padding: 12px 20px; font-size: 16px; margin: 10px 0; cursor: pointer; border: none; background: #4285f4; color: white; border-radius: 8px; transition: 0.3s;}
    button:hover { background: #306fd0;}
    .pdf-preview-list { width: 100%; display: flex; flex-direction: column; gap: 24px; max-height: 320px; overflow-y: auto; margin-bottom: 10px; border-radius: 10px; background: #f7f7f7; padding: 8px;}
    .sortable-list {display: flex; flex-direction: row; gap: 20px;}
    .pdf-preview-file { background: #fff; border-radius: 10px; padding: 12px; box-shadow: 0 2px 5px rgba(0,0,0,0.03); min-width: 120px;}
    .pdf-filename { font-weight: bold; margin-bottom: 5px; color: #4285f4;}
    .file-remove { color: red; cursor: pointer; font-size: 14px; margin-top: 4px;}
    .pdf-pages { display: flex; flex-wrap: wrap; gap: 10px;}
    .sortable-pages {display: flex; flex-wrap: wrap; gap: 10px;}
    .pdf-page-thumb { display: flex; flex-direction: column; align-items: center; margin-bottom: 8px; min-width: 90px;}
    .pdf-page-thumb canvas { width: 80px; height: 110px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.08); margin-bottom: 2px; background: #eee;}
    .pdf-page-thumb span {font-size: 12px;}
    .range-select { margin: 10px 0; }
    progress { width: 100%; margin-top: 10px; height: 18px; border-radius: 5px; }
    @media (max-width:600px) {
      main { max-width: 100%; }
      .sortable-list { flex-direction: column; }
      .sortable-pages { flex-direction: column; }
      .pdf-preview-list { max-height: 220px; }
    }
  </style>
  <!-- SortableJS for drag-and-drop -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
</head>
<body>
<header>PDF Merge & Split Pro</header>
<main>
  <div class="tabs">
    <button class="tab-btn active" data-tab="merge">Merge PDFs</button>
    <button class="tab-btn" data-tab="split">Split PDF</button>
  </div>
  <!-- Merge Section -->
  <div class="tab-content active" id="merge">
    <div class="drop-zone" id="mergeDrop">Drag & drop PDFs here or click to select</div>
    <input type="file" id="mergeFiles" multiple accept="application/pdf">
    <div class="pdf-preview-list">
      <div id="mergeList" class="sortable-list"></div>
    </div>
    <button id="mergeBtn">Merge PDFs</button>
    <progress id="mergeProgress" value="0" max="100" style="display:none;"></progress>
  </div>
  <!-- Split Section -->
  <div class="tab-content" id="split">
    <div class="drop-zone" id="splitDrop">Drag & drop a PDF here or click to select</div>
    <input type="file" id="splitFile" accept="application/pdf">
    <div class="pdf-preview-list">
      <div id="splitList" class="sortable-pages"></div>
    </div>
    <div class="range-select">
      <label>Start page: <input type="number" id="splitStart" min="1" value="1" style="width:40px;"></label>
      <label>End page: <input type="number" id="splitEnd" min="1" value="1" style="width:40px;"></label>
      <button id="selectAllPages" type="button">Select all</button>
    </div>
    <button id="splitBtn">Split Selected Range</button>
    <progress id="splitProgress" value="0" max="100" style="display:none;"></progress>
  </div>
</main>

<script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.5.141/pdf.min.js"></script>
<script>
const tabBtns = document.querySelectorAll('.tab-btn');
const tabContents = document.querySelectorAll('.tab-content');
tabBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    tabBtns.forEach(b => b.classList.remove('active'));
    tabContents.forEach(c => c.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById(btn.dataset.tab).classList.add('active');
  });
});

// --- Merge Tab ---
const mergeFilesArr = [];
setupDropZone(document.getElementById('mergeDrop'), document.getElementById('mergeFiles'), mergeFilesArr, document.getElementById('mergeList'), true);

function setupDropZone(dropZone, input, fileListArray, previewListDiv, isMerge){
  dropZone.addEventListener('click', ()=> input.click());
  dropZone.addEventListener('dragover', e=>{ e.preventDefault(); dropZone.classList.add('dragover'); });
  dropZone.addEventListener('dragleave', e=>{ e.preventDefault(); dropZone.classList.remove('dragover'); });
  dropZone.addEventListener('drop', async e=>{
    e.preventDefault();
    dropZone.classList.remove('dragover');
    const files = Array.from(e.dataTransfer.files).filter(f=>f.type==='application/pdf');
    addNewFiles(fileListArray, files);
    await renderFileList(fileListArray, previewListDiv, isMerge);
  });
  input.addEventListener('change', async ()=>{
    const files = Array.from(input.files);
    addNewFiles(fileListArray, files);
    await renderFileList(fileListArray, previewListDiv, isMerge);
  });
}

function addNewFiles(fileListArray, newFiles) {
  newFiles.forEach(file => {
    if (!fileListArray.some(f => f.name === file.name && f.size === file.size)) {
      fileListArray.push(file);
    }
  });
}

async function renderFileList(files, containerDiv, isMerge){
  containerDiv.innerHTML = '';
  for(let i=0; i<files.length; i++) {
    const file = files[i];
    const fileDiv = document.createElement('div');
    fileDiv.className = 'pdf-preview-file';
    fileDiv.draggable = true;
    fileDiv.dataset.index = i;
    fileDiv.style.cursor = "grab";
    fileDiv.innerHTML = `<div class="pdf-filename">${file.name}</div>`;
    const removeBtn = document.createElement('span');
    removeBtn.textContent = "Remove";
    removeBtn.classList.add('file-remove');
    removeBtn.onclick = () => {
      files.splice(i,1);
      renderFileList(files, containerDiv, isMerge);
    };
    fileDiv.appendChild(removeBtn);

    // Preview first page only for merge
    const previewArea = document.createElement('div');
    previewArea.className = 'pdf-pages';
    fileDiv.appendChild(previewArea);
    try {
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
      const page = await pdf.getPage(1);
      const canvas = document.createElement('canvas');
      canvas.width = 80;
      canvas.height = 110;
      const scale = canvas.width / page.getViewport({scale:1}).width;
      const viewport = page.getViewport({scale});
      canvas.height = viewport.height;
      await page.render({canvasContext: canvas.getContext('2d'), viewport}).promise;
      previewArea.appendChild(canvas);
      previewArea.appendChild(document.createElement('br'));
      previewArea.appendChild(document.createTextNode("Page 1"));
    } catch(e) {
      previewArea.innerHTML = "Preview unavailable";
    }
    containerDiv.appendChild(fileDiv);
  }
  // Make sortable
  Sortable.create(containerDiv, {
    animation: 150,
    onEnd: function (evt) {
      // Rearrange files array to match visual order
      const newOrder = Array.from(containerDiv.children).map(el => parseInt(el.dataset.index));
      const reordered = newOrder.map(idx => files[idx]);
      files.splice(0, files.length, ...reordered);
      renderFileList(files, containerDiv, isMerge);
    }
  });
}

const mergeBtn = document.getElementById('mergeBtn');
const mergeProgress = document.getElementById('mergeProgress');
mergeBtn.addEventListener('click', async ()=>{
  if(mergeFilesArr.length<2){ alert('Select at least 2 PDFs to merge.'); return;}
  mergeProgress.style.display='block';
  mergeProgress.value=0;
  try {
    const mergedPdf = await PDFLib.PDFDocument.create();
    for(let i=0;i<mergeFilesArr.length;i++){
      const file = mergeFilesArr[i];
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await PDFLib.PDFDocument.load(arrayBuffer);
      const pages = await mergedPdf.copyPages(pdf,pdf.getPageIndices());
      pages.forEach(p=>mergedPdf.addPage(p));
      mergeProgress.value=Math.round(((i+1)/mergeFilesArr.length)*100);
    }
    const bytes = await mergedPdf.save();
    const blob = new Blob([bytes],{type:'application/pdf'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download='merged.pdf';
    a.click();
  } catch (e) {
    alert("Failed to merge PDFs. " + e.message);
  }
  mergeProgress.style.display='none';
});

// --- Split Tab ---
const splitFilesArr = [];
let splitPagesArr = [];
let splitFileOriginalOrder = [];
setupDropZone(document.getElementById('splitDrop'), document.getElementById('splitFile'), splitFilesArr, document.getElementById('splitList'), false);

async function renderSplitPages(files, containerDiv){
  containerDiv.innerHTML = '';
  splitPagesArr = [];
  splitFileOriginalOrder = [];
  if (files.length === 0) return;
  const file = files[0];
  try {
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
    const numPages = pdf.numPages;
    document.getElementById('splitStart').max = numPages;
    document.getElementById('splitEnd').max = numPages;
    document.getElementById('splitEnd').value = numPages;
    splitPagesArr = Array.from({length: numPages}, (_, i) => i+1);
    splitFileOriginalOrder = splitPagesArr.slice();

    for(let pageNum = 1; pageNum <= numPages; pageNum++) {
      const pageThumbDiv = document.createElement('div');
      pageThumbDiv.className = 'pdf-page-thumb';
      pageThumbDiv.draggable = true;
      pageThumbDiv.dataset.pageNum = pageNum;
      const canvas = document.createElement('canvas');
      canvas.width = 80;
      canvas.height = 110;
      pageThumbDiv.appendChild(canvas);
      const pageLabel = document.createElement('span');
      pageLabel.textContent = `Page ${pageNum}`;
      pageThumbDiv.appendChild(pageLabel);
      containerDiv.appendChild(pageThumbDiv);

      pdf.getPage(pageNum).then(page => {
        const scale = canvas.width / page.getViewport({scale:1}).width;
        const viewport = page.getViewport({scale});
        canvas.height = viewport.height;
        page.render({canvasContext: canvas.getContext('2d'), viewport}).promise;
      });
    }
    // Make sortable
    Sortable.create(containerDiv, {
      animation: 150,
      onEnd: function (evt) {
        // Update splitPagesArr based on current order
        splitPagesArr = Array.from(containerDiv.children).map(el => parseInt(el.dataset.pageNum));
      }
    });
  } catch(e) {
    containerDiv.innerHTML = "Preview unavailable";
  }
}

// Redraw splitList on file change
document.getElementById('splitFile').addEventListener('change', ()=>{
  renderSplitPages(splitFilesArr, document.getElementById('splitList'));
});
document.getElementById('splitDrop').addEventListener('drop', ()=>{
  setTimeout(()=>renderSplitPages(splitFilesArr, document.getElementById('splitList')),100);
});

// Select all pages button
document.getElementById('selectAllPages').onclick = function() {
  if (splitPagesArr.length) {
    document.getElementById('splitStart').value = 1;
    document.getElementById('splitEnd').value = splitPagesArr.length;
  }
};

const splitBtn = document.getElementById('splitBtn');
const splitProgress = document.getElementById('splitProgress');

splitBtn.addEventListener('click', async ()=>{
  const file = splitFilesArr[0];
  if(!file){ alert('Select a PDF to split.'); return;}
  splitProgress.style.display='block';
  splitProgress.value=0;
  try {
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await PDFLib.PDFDocument.load(arrayBuffer);

    // Range selection
    let start = parseInt(document.getElementById('splitStart').value);
    let end = parseInt(document.getElementById('splitEnd').value);
    if (!start || !end || start > end || start < 1 || end > splitPagesArr.length) {
      alert('Invalid start/end range.');
      splitProgress.style.display='none';
      return;
    }

    // Pages to export in their current visual order
    const pageIndices = splitPagesArr.slice(start-1, end).map(n => n-1); // zero-based
    if (pageIndices.length === 0) {
      alert('No pages selected.');
      splitProgress.style.display='none';
      return;
    }

    const newPdf = await PDFLib.PDFDocument.create();
    const copiedPages = await newPdf.copyPages(pdf, pageIndices);
    copiedPages.forEach(page => newPdf.addPage(page));
    const bytes = await newPdf.save();
    const blob = new Blob([bytes], {type:'application/pdf'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `${file.name.replace('.pdf','')}_split_pages_${start}_to_${end}.pdf`;
    a.click();
  } catch (e) {
    alert("Failed to split PDF. " + e.message);
  }
  splitProgress.style.display='none';
});
</script>
</body>
</html>